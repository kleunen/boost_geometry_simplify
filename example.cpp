#include "simplify.hpp"

#include <iostream>
#include <chrono>

void benchmark(bool use_boost)
{
	// Benchmark overlapping approach
	MultiPolygon poly;
	boost::geometry::read_wkt("MULTIPOLYGON(((0.561648 1,1 1,1 0,0.468083 0,0.52758 0.00800554,0.599683 0.0280924,0.601611 0.265374,0.622693 0.316765,0.69507 0.357497,0.695623 0.429711,0.655111 0.502298,0.696467 0.543147,0.840712 0.593546,0.882583 0.66546,0.852357 0.748213,0.84264 0.789567,0.832667 0.841202,0.832667 0.841202,0.740538 0.873004,0.617349 0.905045,0.566576 0.977697,0.561648 1)),((0 0.801979,0.0308575 0.786234,0.0705513 0.631135,0.141616 0.527248,0.233985 0.505872,0.264777 0.526263,0.336631 0.505009,0.356603 0.422321,0.355803 0.350038,0.375252 0.205364,0.415206 0.0709182,0.45479 0,0 0,0 0,0 0.801979)))", poly);

  	auto const start = std::chrono::steady_clock::now();

	constexpr std::size_t count = 10000;
	for(std::size_t i = 0; i < count; ++i) {
		MultiPolygon result;
		if(use_boost)
	    	boost::geometry::simplify(poly, result, 1.0 / 2048);
		else
	    	simplify(poly, result, 1.0 / 2048);
	}

  	auto const end = std::chrono::steady_clock::now();
  	auto const ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
  	std::cout << (use_boost ? " time boost: " : " time self-intersection: ") << (double)ms / count << std::endl;
}

bool equals(Polygon const &a, Polygon const &b)
{
	if(a.outer().size() != b.outer().size()) return false;
	if(a.inners().size() != b.inners().size()) return false;

	for(std::size_t i = 0; i < a.inners().size(); ++i) {
		if(a.inners()[i].size() != b.inners()[i].size()) return false;
	}

	return (boost::geometry::area(a) - boost::geometry::area(b) < 0.00001);
}

bool equals(MultiPolygon const &a, MultiPolygon const &b)
{
	if(a.size() != b.size()) return false;

	for(std::size_t i = 0; i < a.size(); ++i) {
		if(!equals(a[i], b[i])) return false;
	}

	return (boost::geometry::area(a) - boost::geometry::area(b) < 0.00001);
}

void test(char const *wkt, double distance)
{
	MultiPolygon mp;
	boost::geometry::read_wkt(wkt, mp);

    // Simplify it using distance of 0.5 units
    MultiPolygon simplified;
    simplify(mp, simplified, distance);

    MultiPolygon boost_simplified;
    boost::geometry::simplify(mp, boost_simplified, distance);

	bool match = equals(simplified, boost_simplified);

	if(boost::geometry::area(simplified) != boost::geometry::area(boost_simplified)) std::cout << "Area does not match" << std::endl;

	std::string message;
	if(!boost::geometry::is_valid(boost_simplified, message)) {
		std::cout << "Boost simplify generated invalid geometry: " << message << std::endl;
	}

    std::cout << std::setprecision(12) << std::boolalpha 
        << "  original: " << boost::geometry::is_valid(mp) << " " << boost::geometry::wkt(mp) << "(" << boost::geometry::area(mp) << ")" << std::endl
        << "simplified: " << boost::geometry::is_valid(simplified) << " " << boost::geometry::wkt(simplified) << "(" << boost::geometry::area(simplified) << ")" << std::endl
        << "boost     : " << boost::geometry::is_valid(boost_simplified) << " " << boost::geometry::wkt(boost_simplified) << "(" << boost::geometry::area(boost_simplified) << ")" << std::endl
		<< "match     : " << match << std::endl << std::endl;

	//if(!match) throw std::runtime_error("TEST FAILED");
}

int main()
{
	test("MULTIPOLYGON(((4 0,8 2,8 7,4 9,0 7,0 2,2 1,4 0)))", 1.0);
	test("MULTIPOLYGON(((4 0,8 2,8 7,4 9,0 7,0 2,2 1,4 0),(7 3,7 6,1 6,1 3,4 3,7 3)))", 1.0);

	test("MULTIPOLYGON(((0.561648 1,1 1,1 0,0.468083 0,0.52758 0.00800554,0.599683 0.0280924,0.601611 0.265374,0.622693 0.316765,0.69507 0.357497,0.695623 0.429711,0.655111 0.502298,0.696467 0.543147,0.840712 0.593546,0.882583 0.66546,0.852357 0.748213,0.84264 0.789567,0.832667 0.841202,0.832667 0.841202,0.740538 0.873004,0.617349 0.905045,0.566576 0.977697,0.561648 1)))", 1.0 / 2048.0); 
	test("MULTIPOLYGON(((0 0.801979,0.0308575 0.786234,0.0705513 0.631135,0.141616 0.527248,0.233985 0.505872,0.264777 0.526263,0.336631 0.505009,0.356603 0.422321,0.355803 0.350038,0.375252 0.205364,0.415206 0.0709182,0.45479 0,0 0,0 0,0 0.801979)))", 1.0 / 2048.0); 
	test("MULTIPOLYGON(((0.561648 1,1 1,1 0,0.468083 0,0.52758 0.00800554,0.599683 0.0280924,0.601611 0.265374,0.622693 0.316765,0.69507 0.357497,0.695623 0.429711,0.655111 0.502298,0.696467 0.543147,0.840712 0.593546,0.882583 0.66546,0.852357 0.748213,0.84264 0.789567,0.832667 0.841202,0.832667 0.841202,0.740538 0.873004,0.617349 0.905045,0.566576 0.977697,0.561648 1)),((0 0.801979,0.0308575 0.786234,0.0705513 0.631135,0.141616 0.527248,0.233985 0.505872,0.264777 0.526263,0.336631 0.505009,0.356603 0.422321,0.355803 0.350038,0.375252 0.205364,0.415206 0.0709182,0.45479 0,0 0,0 0,0 0.801979)))", 1.0 / 2048.0); 
	 test("MULTIPOLYGON(((1149.69 2047,2047 2047,2047 0,958.166 0,1079.96 16.3873,1227.55 57.5051,1231.5 543.221,1274.65 648.418,1422.81 731.796,1423.94 879.618,1341.01 1028.2,1425.67 1111.82,1720.94 1214.99,1806.65 1362.2,1744.77 1531.59,1724.88 1616.24,1704.47 1721.94,1704.47 1721.94,1515.88 1787.04,1263.71 1852.63,1159.78 2001.35,1149.69 2047)),((0 1641.65,63.1653 1609.42,144.419 1291.93,289.888 1079.28,478.967 1035.52,541.999 1077.26,689.084 1033.75,729.966 864.491,728.329 716.528,768.141 420.38,849.927 145.17,930.955 0,0 0,0 0,0 1641.65)))", 1.0);

	// Boost generates self-intersection
	test("MULTIPOLYGON(((-3.69338090482 55.715692269,-3.6926079 55.7159519,-3.6924337 55.7151986,-3.6930661 55.715117,-3.6930157 55.7147726,-3.69338091231 55.7147132692,-3.69338090482 55.715692269)),((-3.69338090688 55.7142211068,-3.6933768 55.7141871,-3.6929634 55.7141725,-3.6929954 55.7145025,-3.6923885 55.7145554,-3.6923617 55.7147792,-3.6914998 55.7150295,-3.6912315 55.7134982,-3.6893145 55.7140656,-3.6885759 55.7143373,-3.6878468 55.7144903,-3.6885649 55.7161566,-3.6879954 55.7164484,-3.6873303 55.7153805,-3.686997 55.7156142,-3.6864469 55.716,-3.686103 55.716241,-3.6862139 55.7163757,-3.6858363 55.7166538,-3.6853115 55.7167809,-3.6849156 55.7164513,-3.6845733 55.7165856,-3.6839978 55.7159007,-3.6839527 55.7158282,-3.6835296 55.7160357,-3.6808072 55.7170818,-3.6807411 55.7168675,-3.6805504 55.7150641,-3.682455 55.7150385,-3.6834742 55.7143695,-3.6845373 55.7140717,-3.6845125 55.7139033,-3.684369 55.7127279,-3.6806985 55.7123158,-3.6810755 55.7133089,-3.6813647 55.7139107,-3.681652 55.7137697,-3.6820175 55.7147227,-3.6805049 55.7147351,-3.6795311 55.7129405,-3.6778782 55.7129041,-3.6777658 55.714827,-3.6760112 55.7159293,-3.6752767 55.7124876,-3.6715262 55.7125441,-3.6712776 55.7122602,-3.6708886 55.711493,-3.6708159 55.7113861,-3.6706013 55.7110893,-3.670957 55.7111165,-3.6731425 55.7111427,-3.6742991 55.709201,-3.6753334 55.7095268,-3.6758595 55.710859,-3.6788138 55.7112687,-3.676502 55.7081632,-3.6780904 55.7067399,-3.6788205 55.7067314,-3.6792276 55.707739,-3.6793662 55.7086275,-3.6806176 55.7088675,-3.6804964 55.7104918,-3.6803571 55.7111529,-3.6809193 55.7114274,-3.6806673 55.7120776,-3.6843319 55.712513,-3.6853143 55.7126239,-3.6900574 55.7130953,-3.6914546 55.71325,-3.6915457 55.7128876,-3.6919092 55.712801,-3.6913866 55.7112063,-3.6933809 55.7105007,-3.69338090688 55.7142211068)),((-3.6933809 55.7105007,-3.6933589 55.7104093,-3.6925489 55.710479,-3.6924738 55.7097065,-3.6933482 55.7096368,-3.69338090149 55.7095931641,-3.6933809 55.7105007)),((-3.69338091082 55.7090016493,-3.692978 55.7091164,-3.692286 55.7091593,-3.6917755 55.7087839,-3.6906731 55.7089272,-3.6902922 55.7073596,-3.6908162 55.7071423,-3.6910434 55.7069466,-3.6912775 55.7066595,-3.6908162 55.7064289,-3.690583 55.7055368,-3.6920467 55.7047551,-3.6918633 55.7046247,-3.6926388 55.7037173,-3.69338090692 55.7037081763,-3.69338091082 55.7090016493)))", 0.0006);

	benchmark(true);   
	benchmark(false);   
	return 0;
}
